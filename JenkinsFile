pipeline {
    agent { label 'regular-memory-node-c7' }
    options { timestamps() }
    stages {
        stage('checkout') {
            steps {
                script {
                    repo_url = "https://github.com/snowflakedb/frostdb.git"
                    scmInfo = checkout scm
                    println("${scmInfo}")
                    //extracting the LDAP portion from sfc-gh-xxx
                    user_id=sh(script: "git show -s --pretty=%ae | cut -d '@' -f 1 | cut -d '-' -f 3", returnStdout: true).trim()
                    precommit_job_status = "SUCCESS"
                }
            }
        }
        stage('Clang Format Check') {
            steps {
                script {
                    println("**** Starting Clang format check  **** ")

                    setBuildStatus("clang format check", "clang format check", "PENDING", currentBuild.absoluteUrl);

                    def j = build job: "FDB_Build/FDB_clang_format_check",
                            parameters: [
                                string(name: 'ARCH', value: "x86_64"),
                                string(name: 'GIT_REMOTE', value: "${repo_url}"),
                                string(name: 'GIT_SPECIFIER', value: "${scmInfo.GIT_COMMIT}")
                            ],
                    propagate: false,
                    wait: true

                    setBuildStatus("clang format check", "clang format check", j.result, j.absoluteUrl+"/clang");

                    if ("${j.result}" == "SUCCESS") {
                        currentBuild.result = 'SUCCESS'
                    } else {
                        currentBuild.result = 'FAILURE'
                        println("clang format check failure.")
                    }
                }
            }
        }
        stage('Check Git Comment') {
            steps {
                script {
                    def trigger_comment = "@fdb-ci precommit start"
                    def build_trigger_cause = "${currentBuild.getBuildCauses()[0].shortDescription}"
                    println("Build Trigger Cause : ${build_trigger_cause}")
                    if ("${build_trigger_cause}" == "GitHub pull request comment" &&
                            "${currentBuild.getBuildCauses()[0].commentBody}".contains("${trigger_comment}")) {
                        println("Moving ahead with pipeline")
                        setBuildStatus("github_comment","Criteria Satisfied",
                           "SUCCESS", currentBuild.absoluteUrl);
                    } else {
                        setBuildStatus("github_comment",
                                       "Please comment '${trigger_comment}' to start precommit job",
                                       "FAILURE", currentBuild.absoluteUrl);

                        println("FDB_Precommit build job execution is skipped. Please comment: ${trigger_comment}")
                        currentBuild.result = 'FAILURE'
                        error("Aborting the build.")
                    }
                }
            }
        }
        stage('Build and Test') {
            parallel {
                stage('Build and Test - PRERELEASE') {
                    steps {
                        script {
                            trigger_job("precommit_prerelease", "precommit_prerelease.yml")
                        }
                    }
                }

                stage('Build and Test - TSAN') {
                    steps {
                        script {
                            trigger_job("precommit_tsan", "precommit_tsan.yml")
                        }
                    }
                }

                stage('Build and Test - ASAN') {
                    steps {
                        script {
                            trigger_job("precommit_asan", "precommit_asan.yml")
                        }
                    }
                }

                stage('Build and Test - UBSAN') {
                    steps {
                        script {
                            trigger_job("precommit_ubsan", "precommit_ubsan.yml")
                        }
                    }
                }
            }
        }
        stage('Update Build Status') {
            steps {
                script {
                    if ("${precommit_job_status}" == "SUCCESS") {
                        currentBuild.result = "SUCCESS"
                    } else {
                        currentBuild.result = "FAILURE"
                    }
                }
            }
        }
    }
}

void trigger_job(jobname, profile) {
    script {
        setBuildStatus(jobname, "Build And Test", "PENDING", currentBuild.absoluteUrl);
        def job_params = [string(name: 'ARCH', value: "x86_64"),
                         string(name: 'GIT_REMOTE', value: "${repo_url}"),
                         string(name: 'GIT_SPECIFIER', value: "${scmInfo.GIT_COMMIT}"),
                         string(name: 'SLACK_USER_NAME', value: "${user_id}"),
                         string(name: 'PR_ID', value: "${env.BRANCH_NAME}")]

        def j = build job: 'FDB_BuildAndTest/FDB_Precommit',
                parameters: job_params + [string('name': 'BUILD_TEST_PROFILE', value: profile)],
                propagate: false,
                wait: true

        setBuildStatus(jobname, "Build And Test", j.result, j.absoluteUrl);

        if ("${j.result}" == "FAILURE" || "${j.result}" == "ABORTED") {
            // In case if any of the build or test fails we will mark current build as FAILURE
            precommit_job_status = "FAILURE"
        }
    }
}

void setBuildStatus(context, message, state, url) {
    withCredentials([
    usernamePassword(credentialsId: 'jenkins-snowflakedb-github-app',usernameVariable: 'GITHUB_USER',
                     passwordVariable: 'GITHUB_TOKEN'),
    ]){
    step([
        $class: "GitHubCommitStatusSetter",
        contextSource: [$class: "ManuallyEnteredCommitContextSource", context: context],
        errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
        reposSource: [$class: "ManuallyEnteredRepositorySource", url: "${repo_url}"],
        statusBackrefSource: [$class: "ManuallyEnteredBackrefSource", backref: url],
        statusResultSource: [ $class: "ConditionalStatusResultSource", results: [[$class: "AnyBuildResult",
                             message: message, state: state]]]
    ]);
    }
}
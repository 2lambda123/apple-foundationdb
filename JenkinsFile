import hudson.model.Result
import hudson.model.Run
import jenkins.model.CauseOfInterruption.UserInterruption

pipeline {
    agent { label 'regular-memory-node-c7' }
    options { timestamps() }
    stages {
        stage('checkout') {
            steps {
                script {
                    abortPreviousBuilds()
                    repo_url = "https://github.com/snowflakedb/frostdb.git"
                    scmInfo = checkout scm
                    println("${scmInfo}")
                    precommit_job_status = "SUCCESS"
                    labels = getLabels()
                }
            }
        }
        stage('Clang Format Check') {
            steps {
                script {
                    println("**** Starting Clang format check  **** ")
                    def j = build job: "FDB_Build/FDB_clang_format_check",
                            parameters: [
                                string(name: 'ARCH', value: "x86_64"),
                                string(name: 'GIT_REMOTE', value: "${repo_url}"),
                                string(name: 'GIT_SPECIFIER', value: "${scmInfo.GIT_COMMIT}")
                            ],
                    propagate: false,
                    wait: true

                    if ("${j.result}" == "SUCCESS") {
                        currentBuild.result = 'SUCCESS'
                        createCheck("clang format check", "clang format check", j.absoluteUrl+"/clang", "completed", "success");
                    } else {
                        currentBuild.result = 'FAILURE'
                        println("clang format check failure.")
                        createCheck("clang format check", "clang format check", j.absoluteUrl+"/clang", "completed", "failure");
                    }
                }
            }
        }
        stage('Check Git Comment') {
            steps {
                script {
                    def trigger_comment = "@fdb-ci precommit start"
                    def build_trigger_cause = "${currentBuild.getBuildCauses()[0].shortDescription}"
                    println("Build Trigger Cause : ${build_trigger_cause}")

                    if ("${build_trigger_cause}" == "GitHub pull request comment" &&
                            "${currentBuild.getBuildCauses()[0].commentBody}".contains("${trigger_comment}")) {
                        println("Moving ahead with pipeline")

                        //extracting the LDAP portion from commentAuthor sfc-gh-xxx
                        user_id = "${currentBuild.getBuildCauses()[0].commentAuthor}".split("-")[2]
                        createCheck("github_comment", "Criteria Satisfied", "", "completed", "success");
                    } else {
                        def triggerMessage = "To start Full CI, Please comment: @fdb-ci precommit start"
                        createCheck("github_comment", triggerMessage, triggerMessage, "completed", "failure");
                        println("FDB_Precommit build job execution is skipped. Please comment: ${trigger_comment}")
                        currentBuild.result = 'FAILURE'
                        error("Aborting the build.")
                    }
                }
            }
        }
        stage('Build and Test') {
            parallel {
                stage('Build and Test - PRERELEASE') {
                    steps {
                        script {
                            trigger_job("precommit_prerelease", "precommit_prerelease.yml")
                        }
                    }
                }

                stage('Build and Test - TSAN') {
                    steps {
                        script {
                            trigger_job("precommit_tsan", "precommit_tsan.yml")
                        }
                    }
                }

                stage('Build and Test - ASAN') {
                    steps {
                        script {
                            trigger_job("precommit_asan", "precommit_asan.yml")
                        }
                    }
                }

                stage('Build and Test - UBSAN') {
                    steps {
                        script {
                            trigger_job("precommit_ubsan", "precommit_ubsan.yml")
                        }
                    }
                }
            }
        }
        stage('Update Build Status') {
            steps {
                script {
                    if ("${precommit_job_status}" == "SUCCESS") {
                        currentBuild.result = "SUCCESS"
                    } else {
                        currentBuild.result = "FAILURE"
                    }
                }
            }
        }
    }
}

void trigger_job(jobName, profile) {
    script {
        if (labels.contains("bypass_all_checks")) {
            msg = "Skipped due to label 'bypass_all_checks'"
            createCheck(jobName, msg, msg, "completed", "success");
            return
        }

        createCheck(jobName, "Build and Test", "In Progress", "in_progress", "");

        def job_params = [string(name: 'ARCH', value: "x86_64"),
                         string(name: 'GIT_REMOTE', value: "${repo_url}"),
                         string(name: 'GIT_SPECIFIER', value: "${scmInfo.GIT_COMMIT}"),
                         string(name: 'SLACK_USER_NAME', value: "${user_id}"),
                         string(name: 'PR_ID', value: "${env.BRANCH_NAME}"),
                         string(name: 'ALWAYS_TEST', value: "true")]

        def j = build job: 'FDB_BuildAndTest/FDB_Precommit',
                parameters: job_params + [string('name': 'BUILD_TEST_PROFILE', value: profile)],
                propagate: false,
                wait: true

        def logContent = Jenkins.getInstance().getItemByFullName("FDB_BuildAndTest/FDB_Precommit").getBuildByNumber(j.number).logFile.text
        def logLines = logContent.split("\n")
        def testCount = 0
        def details = []
        def jobConclusion = "success"
        def failureCount = 0
        def summary = ""

        //Parsing line "2023-04-03 14:31:28  Build job run status:FAILURE http://job_url_link" to get build_info
        for (line in logLines) {
            if (line.contains("Build job run status:")) {
                build_details = line.split("Build job run status:")
                build_info = build_details[1].split(" ")
                if (build_info[0] != "SUCCESS") {
                    jobConclusion = "failure"
                    failureCount += 1
                }
                summary += "Build Status: " + build_info[0] + ", Build Job URL : " + build_info[1] + " , "
            }
            if (line.contains("Test job run status:")) {
                testCount += 1
                build_details = line.split("Test job run status:")
                build_info = build_details[1].split(" ")

                if (build_info[0] != "SUCCESS") {
                     // Ignore test failure if label 'bypass_test_failures' is set
                    if (!labels.contains("bypass_test_failures")) {
                        jobConclusion = "failure"
                    }
                    failureCount += 1
                }

                summary += " Test " + Integer.toString(testCount) + ": Status: " + build_info[0] +
                           " Test Job URL : " + build_info[1] + " ,"

                if (labels.contains("bypass_test_failures")) {
                    jobConclusion = "success"
                }

            }
        }
        title = "Failure count : " + Integer.toString(failureCount)
        createCheck(jobName, title, summary, "completed", jobConclusion);

        if (jobConclusion == "failure") {
            // In case if any of the build or test fails we will mark current build as FAILURE
            precommit_job_status = "FAILURE"
        }
    }
}

void createCheck(context, title, summary, jobStatus, jobConclusion) {
    withCredentials([usernamePassword(credentialsId: 'Jenkins-FDB-GithubApp ',
    usernameVariable: 'GITHUB_USER',
    passwordVariable: 'GITHUB_TOKEN')]) {
        //create check
        // Handling separate condition for 'in_progress' and 'completed' jobStatus because
        //as per Github API's providing conclusion will automatically set the status parameter to completed
        if ("${jobStatus}" == "in_progress") {
            sh """curl -S -u "$GITHUB_USER:$GITHUB_TOKEN" \\
                  -X POST https://api.github.com/repos/snowflakedb/frostdb/check-runs \\
                 -d '{"name":"${context}","head_sha":"${scmInfo["GIT_COMMIT"]}",
                      "status":"in_progress",
                      "output":{"title":"${title}","summary":"${summary}"}'
            """
        }
        if ("${jobStatus}" == "completed") {
            sh """curl -S -u "$GITHUB_USER:$GITHUB_TOKEN" \\
                  -X POST https://api.github.com/repos/snowflakedb/frostdb/check-runs \\
                 -d '{"name":"${context}","head_sha":"${scmInfo["GIT_COMMIT"]}",
                      "status":"completed", "conclusion":"${jobConclusion}",
                      "output":{"title":"${title}","summary":"${summary}"}'
            """
        }
    }
}

void getLabels() {
    //taking pr_id from branch i.e taking 167 from PR-167
    pr_id = env.BRANCH_NAME.split("-")[1]
    withCredentials([usernamePassword(credentialsId: 'Jenkins-FDB-GithubApp',
    usernameVariable: 'GITHUB_USER',
    passwordVariable: 'GITHUB_TOKEN')]) {
        sh """
            curl -S -u "$GITHUB_USER:$GITHUB_TOKEN" "https://api.github.com/repos/snowflakedb/frostdb/pulls/${pr_id}" -o pr.json
        """
    }
    def labels = sh(script:"jq -r '.labels[].name' pr.json; rm pr.json", returnStdout: true)
    labels = labels.split("\n")
    return labels
}

//Aborting previous runs if any in progress
def abortPreviousBuilds() {
    //This will look for previous job under Full project name: SnowFlake-FoundationDB/frostdb/<PR-ID>
    Run previousBuild = currentBuild.rawBuild.getPreviousBuildInProgress()

    while (previousBuild != null) {
        if (previousBuild.isInProgress()) {
            def executor = previousBuild.getExecutor()
            if (executor != null) {
                echo ">> Aborting older build #${previousBuild.number}"
                executor.interrupt(Result.ABORTED, new UserInterruption(
                    "Aborted by newer build #${currentBuild.number}"
                ))
            }
        }
        previousBuild = previousBuild.getPreviousBuildInProgress()
    }
}
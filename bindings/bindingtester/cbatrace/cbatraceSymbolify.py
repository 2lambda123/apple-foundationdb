#!/usr/bin/env python3
#
# cbatraceSymbolify.py
#  
# This file is used by the cbatrace FDB feature to mainly generate cbatracefdb_c.g.cpp,
# the cpp file that will be used to produce the shared library libcbatracefdb_c.so
# as a wrapper of FDB C bindings shared library libfdb_c.so. 
# 
# This source file is part of the FoundationDB open source project
#
# Copyright 2013-2018 Apple Inc. and the FoundationDB project authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import os
import re
import sys
import shutil
import getopt

# Symbols:
#   a class that holds the result of parsing fdb_c.h and fdb_c.cpp files  
# --------------------------------------------------------------------------------
class Symbols:
    types = set()    # set of type forward declarations 
    wrappers = set() # set of funcation wrappers 
    names = set()    # set of function names  

# initCppfile():
#   This function is used to init the cbatracefdb_c.g.cpp target file from the seed 
#   utility file cbatraceSeedUtil.in.cpp. It performs a simpy copy of files.  
# --------------------------------------------------------------------------------
def initCppFile(seedFileName, cppFileName):
    # write the code-generated note
    with open(cppFileName, 'w') as f:
        f.write("// ////////////////////////////////////////////////////////////////////////////////////// //\n")
        f.write("// DO NOT EDIT THIS FILE BY HAND.                                                         //\n")
        f.write("// THIS FILE IS GENERATED DURING COMPILATION USING SCRIPT CBATRACESYMBOLIFY.PY.           //\n")  
        f.write("// To regenerate this file from the top level of a FoundationDB repository checkout, run: //\n")
        f.write("// $ python3 bindings/bindingtester/cbatrace/cbatraceSymbolify.py                         //\n") 
        f.write("//          -o bindings/bindingtester/cbatrace/cbatracefdb_c.g.cpp                        //\n")    
        f.write("//             bindings//c/foundationdb/fdb_c.h                                           //\n")
        f.write("//             bindings/c/fdb_c.cpp                                                       //\n")
        f.write("// ////////////////////////////////////////////////////////////////////////////////////// //\n")
        f.write("\n")

    # append the seed file 
    with open(cppFileName, 'a') as outfile, open(seedFileName) as infile:
        outfile.write(infile.read())

# genFunctionActualParams():
#   This function is used to ....
# --------------------------------------------------------------------------------
def genFunctionActualParams(functionSet, functionName, functionFormalParams):
    # remember to report the function 
    if functionName != 'fdb_transaction_get_estimated_range_size_bytes':
      functionSet.add(functionName)

    # remove any comments in the parameters declaration 
    # e.g., see API fdb_future_get_error with /* = NULL */
    functionFormalParams = re.sub(r'/\*.*?\*/', '', functionFormalParams)

    # find all actual parameters, i.e., parameters ending with "," or ")" 
    params = re.findall('(\w+)\s*[,)]', functionFormalParams)

    # process the actual parameters to build one string. 
    # init actual parameters to construct 
    actualParams = ''
    for param in params:
        # use "," as a separator
        if actualParams != '':
            actualParams += ', '
        actualParams += str(param) 
    
    # return resulting string with list of actual parameters 
    actualParams = '( ' + actualParams + ' )'

    # done return the result 
    return actualParams  

# genTypess():
#   This function is used to parse the input header file, i.e., fdb_c.h, and 
#   generate a set of type forward declarations, one per each specific type 
#   created and used in FDB APIs (in fdb_c.cpp file).  
# --------------------------------------------------------------------------------
def genTypes(headerFile):
    # regular expresson to extrace FDB APIs signatures 
    # (function name, arguments, and retrun type) 
    r = re.compile("(struct|typedef)\s+" # Beginning of the string either struct or type def 
                   "(\w+)\s+"            # STD type for typedef or orginal type for struct         
                   "(\w+)\s*[;]")        # Type name, the word before ending ';'

    # extract types from the header file 
    with open(headerFile, 'r') as f:
        types = sorted(set( 
            m.group(1) 
            + ' ' 
            + (m.group(3) if m.group(1) == 'struct' else m.group(2) + ' ' + m.group(3)) 
            + ';'     
        for m in r.finditer(" ".join(f.read().split()))))

    # done return the result 
    return types

# genWrappers():
#   This function is used to parse the input source file, i.e., fdb_c.cpp, and 
#   generate a set of new wrapper functions, one for each function in the file. 
#   Functions are listed in alphabetical order.  
# --------------------------------------------------------------------------------
def genWrappers(sourceFile):
    # regular expresson to extrace FDB APIs signatures 
    # (function name, arguments, and retrun type) 
    r = re.compile("DLLEXPORT\s+"    # Beginning of the string 
                   "([^(]*)"         # Return type        
                   "(fdb_[^(]*)"     # Name of the function. Until first '('
                   "([(][^{]*[)])")  # Function formal arguments. Until first '{'

    # extract the signature of the functions from the input file 
    # and wrap them using macros 
    acceptAPIs = set() 
    with open(sourceFile, 'r') as f:
        wrappers = sorted(set(
        '/* ' + m.group(2) + '() */\n'    
        + ('MAKE_FUNCTION_VOID' if m.group(1).strip() == 'void' else 'MAKE_FUNCTION_RET')    
        +'(\n' 
        + ( m.group(1) + '\n, ' 
        +   m.group(2) + '\n, ' 
        +   m.group(3) + '\n, ' 
        +   genFunctionActualParams(acceptAPIs, m.group(2).strip(), m.group(3)) ) 
        + '\n)\n' 
        for m in r.finditer( " ".join(f.read().split()) ) ) )
    
    # done return the result 
    return wrappers, acceptAPIs

# symbolify():
#   This function is used to parse input files i.e., fdb_c.h and fdb_c.c and then 
#   generate forward declarations of FDB API specific types and function signatures 
#   (i.e., definitions) that will be used to produce the cbatracefdb_c.cpp file.
#   cbatracefdb_c.cpp is used to generate shared library libcbatracefdb_c.so. 
# --------------------------------------------------------------------------------
def symbolify(headerFile, sourceFile):
    # create an instance of symbols 
    symbols = Symbols()

    # parse the .h input file and generate forward declarations of FDB specific types 
    symbols.types = genTypes(headerFile)
     
    # parse the .c input file and generate wrapper funciton definitions of FDB shared 
    # library APIs    
    symbols.wrappers, symbols.names = genWrappers(sourceFile)

    # done return the list of symbols 
    return symbols

# genDestructor():
#   This function is used to generate the definiton of the destructor function  
# --------------------------------------------------------------------------------
def genDestructor(functionNames): 
    endFctBody = """
/* 
 * end():
 *   This function is called when the dynamic library is un-loading.
 *   It is primarily called to report and show a summary of the API calls.
 */
static void end (void) {
  // just for tracing. Uncomment if needed   
  // printf("libctracefdb_c: shutting down File=%p 0\\n", outputFile);  
  // display the summary for API calls counters 
  fprintf(outputFile, \" <Event Type=\\"summary\\" Name=\\"totals\\">\\n");
  """
    # append the function names along with their call counts  
    for fct in functionNames :
      endFctBody = endFctBody + '\n  xmlWriteEvent(outputFile, 2, "api", "' + fct + '", _count_' + fct + '.load());'
    
    # add the tail of the function  
    endFctBody = endFctBody + """

  // generate closing xml tags 
  fprintf(outputFile, " </Event>\\n");
  fprintf(outputFile, "</Trace>\\n");

  // flush and close the file 
  fclose(outputFile);  
}
"""
    #done 
    return endFctBody

# appendCppFile():
#   This function is used to complete the content of the cpp file used
#   to generate the wrapper shared library. 
#   This function adds:
#    - forward declarations of FDB specific types 
#    - wrapper functions definitions 
#    - destructor function definition
# NOTE: 
#   This function must be called after initCppFile()
# --------------------------------------------------------------------------------
def appendCppFile(symbols, cppFile):
    with open(cppFile, 'a') as f:
      f.write('\n\n')
      f.write('\n/* --------------------------------------------------------------------- */')
      f.write('\n/*                    TYPES FORWARD DECLARATIONS                         */')
      f.write('\n/* --------------------------------------------------------------------- */')
      f.write('\n')
      f.write('\n'.join(symbols.types))
      f.write('\n\n')
      f.write('\n/* --------------------------------------------------------------------- */')
      f.write('\n/*            FDB CLIENT INJECT/WRAPPER APIs DEFINITIONS                 */')
      f.write('\n/* --------------------------------------------------------------------- */')
      f.write('\n')
      f.write('\n'.join(symbols.wrappers))
      f.writelines(genDestructor(symbols.names)) 
      f.write('\n')

# genLibCppFile():
#   This function is used to generate the cpp file (with content) used
#   to generate the wrapper shared library libcbatracefdb_c.so. 
# --------------------------------------------------------------------------------
def genLibCppFile(headerFile, sourceFile, outputFile):  
    # Initilize the cpp file using the cbatraceSeedUtil.in.cpp as a seed. 
    # It creates a .cpp file with include header files, a set of helper 
    # functions and macros which are used to generate the shared library APIs.
    cppFile = 'cbatracefdb_c.g.cpp' if outputFile == '' else outputFile
    utlFile = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'cbatraceSeedUtil.in.cpp')
    initCppFile(utlFile, cppFile)
        
    # parse the .h and .c input files to extract definitions of used types and functions 
    symbols = symbolify(headerFile, sourceFile) 

    # wrapp library functions and append the new definitions into the cpp file. 
    appendCppFile(symbols, cppFile); 

# genSymbolsFile():
#   This function is used to generate a file containing the list of function
#   symbols from the fdb_c.cpp file. 
#   The funcations are listed in alphabetical order. 
# --------------------------------------------------------------------------------
def genSymbolsFile(sourceFile, outputFile): 
    # set file name
    symbolsFile = 'cbatracefdb_c.g.sym' if outputFile == '' else outputFile

    # regular expresson to extrace FDB APIs signatures 
    # (function name, arguments, and retrun type) 
    r = re.compile("DLLEXPORT\s+[^(]*"  # Beginning of a function + return type               
                   "(fdb_[^(]*)")       # Name of the function = everything 
                                        # before the first opening parenthesis 

    # extract the signature of the functions from the input file 
    # and wrap them using macros 
    with open(sourceFile, 'r') as f:
        symbols = sorted(set(
        m.group(1) + '()\n' 
        for m in r.finditer( " ".join(f.read().split()) ) ) )

    # write the result in the output file 
    with open(symbolsFile, 'w') as f:
      f.write("// ////////////////////////////////////////////////////////////////////////////////////// //\n")
      f.write("// DO NOT EDIT THIS FILE BY HAND.                                                         //\n")
      f.write("// THIS FILE IS GENERATED DURING COMPILATION USING SCRIPT CBATRACESYMBOLIFY.PY.           //\n")  
      f.write("// To regenerate this file from the top level of a FoundationDB repository checkout, run: //\n")
      f.write("// $ python3 bindings/bindingtester/cbatrace/cbatraceSymbolify.py                         //\n") 
      f.write("//          -s -o bindings/bindingtester/cbatrace/cbatracefdb_c.g.sym                     //\n")    
      f.write("//                bindings//c/foundationdb/fdb_c.h                                        //\n")
      f.write("//                bindings/c/fdb_c.cpp                                                    //\n")
      f.write("// ////////////////////////////////////////////////////////////////////////////////////// //\n")    
      f.write('\n')      
      f.write("/* -------------------------------------------------------------------------------------- */\n")
      f.write("/*                FDB C BINDINGS CLIENT APIs (only NAMES in alphabetical order)           */\n")
      f.write("/* -------------------------------------------------------------------------------------- */\n")
      f.write("")
      f.write(''.join(symbols))
      f.write("\n")    

# ShowCommand():
#   Helper for showing help information
# --------------------------------------------------------------------------------
def showCommandHelp():
    # print command options 
    showHelp = """
    cbatraceSymbolify.py - A helper utility for generating a cpp code file
      that is mainly used to produce a shared library libcbatracefdb_c.so
      as a wrapper of FDB C bindings shared library libfdb_c.so
      
      Usage: python3 cbatraceSymbolify.py [options] fdb_c.cpp [fdb_c.h]
      Options:
         -h             : Show this help
         -w (default)   : Generates a cpp code file with FDB types forward declarations and
                          a list of wrapper functions, one for each FDB function from 
                          the fdb_c.cpp file. Input files fdb_c.h and fdb_c.cpp are mandatory.
         -s             : Produces an ordered list of C bindings Symbol names.
                          In this case fdb_c.h is optional.
         -o <file_name> : Spedifies the name of the output file.
                          Defaults to cbatracefdb_c.g.cpp or cbatracefdb_c.g.sym
                          if the fdb_c.h is missing.
    
      Examples:
        - parse fdb_c.h and fdb_c.cpp to generate cpp code file with default name cbatracefdb_c.g.cpp
          > python3 cbatraceSymbolify.py -w db_c.h fdb_c.cpp
          or simply
          > python3 cbatraceSymbolify.py fdb_c.h fdb_c.cpp
    
        - same as above, but explicitly name the output file.
          > python3 cbatraceSymbolify.py -o myWrapperFunctions.cpp fdb_c.h fdb_c.cpp 
    
        - parse fdb_c.cpp and generate a file containing the list of C binding Symbol names
          > python3 cbatraceSymbolify.py -s fdb_c.cpp
    
        - same as above, but by explicitly naming the output file
          > python3 cbatraceSymbolify.py -s -o myApiSymbols.sym fdb_c.cpp 
    """
    print(showHelp)
    # exit 
    sys.exit()

# processCommandArguments():
#   Process the command arguments. Checks for inputs and options in the arguments, 
#   redirects to the show command help if the inputs/options are not well-formed. 
# --------------------------------------------------------------------------------
def processCommandArguments(args):
    # input files are arguments without (short) options
    try:
        options, inputFiles = getopt.getopt(args, "hwso:", ["ofile="])
    except getopt.GetoptError:
        showCommandHelp()

    # we expect at least one input file (i.e., fdb_c.cpp) and max two (+ fdb_c.h)
    if (len(inputFiles) < 1 or len(inputFiles) > 2):
        showCommandHelp()

    # process the options. No need to check for -w option. It is the default. 
    # NOte: if option -l is specified it (i.e., generation the list of function names) will prime.   
    genLibCppFile = True 
    outputFile = ''
    for opt, arg in options:
        if opt == '-h':
            showCommandHelp()
        elif opt == '-o':
            if arg == '':
                showCommandHelp()
            outputFile = arg
        elif opt == '-s':
            genLibCppFile = False

    # get the input FDB files. We expect a must to have fdb_c.cpp and the optional fdb_c.h
    # fdb_c.h is a must to have if -w option is specified  
    fdb_c_cpp = ''
    fdb_c_h = ''
    for fileName in inputFiles:
        if fileName.endswith("fdb_c.cpp"):
            fdb_c_cpp = fileName
        elif fileName.endswith("fdb_c.h"): 
            fdb_c_h = fileName 

    # verify and validate arguments 
    if (fdb_c_cpp == '' or (genLibCppFile and fdb_c_h == '')): 
        showCommandHelp()

    # done 
    return genLibCppFile, fdb_c_h, fdb_c_cpp, outputFile

# run
if __name__ == '__main__':
  # get input   
  (genCppFile, fdb_c_h, fdb_c_cpp, outputFile) = processCommandArguments(sys.argv[1:])

  # proceed  
  if genCppFile:
    # generate the wrapper shared-library cpp file 
    genLibCppFile(fdb_c_h, fdb_c_cpp, outputFile)
  else:
    # generate the list of functions in the fdb_c.cpp file 
    genSymbolsFile(fdb_c_cpp, outputFile) 




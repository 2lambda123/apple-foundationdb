#[allow(dead_code, unused_imports)]
#[path = "../../target/flatbuffers/RegisterWorkerRequest_generated.rs"]
mod register_worker_request;

// #[allow(dead_code, unused_imports)]
// #[path = "../../target/flatbuffers/RegisterWorkerReply_generated.rs"]
// mod register_worker_reply;

// TODO: Move the rest of these includes into test-only packages:

#[allow(dead_code, unused_imports)]
#[path = "../../target/flatbuffers/LocalityData_generated.rs"]
mod locality_data;

#[allow(dead_code, unused_imports)]
#[path = "../../target/flatbuffers/ClientWorkerInterface_generated.rs"]
mod client_worker_interface;

use crate::flow::{
    file_identifier::{IdentifierType, ParsedFileIdentifier},
    Endpoint, FlowMessage, Result,
};
use crate::services::ConnectionKeeper;

use flatbuffers::FlatBufferBuilder;

use std::sync::Arc;

const REGISTER_WORKER_REQUEST_FILE_IDENTIFIER: ParsedFileIdentifier = ParsedFileIdentifier {
    file_identifier: 14332605,
    inner_wrapper: IdentifierType::None,
    outer_wrapper: IdentifierType::None,
    file_identifier_name: Some("RegisterWorkerRequest"),
};

const REGISTER_WORKER_RESPONSE_FILE_IDENTIFIER: ParsedFileIdentifier = ParsedFileIdentifier {
    file_identifier: 16475696,
    inner_wrapper: IdentifierType::Optional,
    outer_wrapper: IdentifierType::ErrorOr,
    file_identifier_name: Some("RegisterWorkerReply"),
};

thread_local! {
    static REQUEST_BUILDER : std::cell::RefCell<FlatBufferBuilder<'static>> = std::cell::RefCell::new(FlatBufferBuilder::with_capacity(1024));
}

thread_local! {
    static REPLY_BUILDER : std::cell::RefCell<FlatBufferBuilder<'static>> = std::cell::RefCell::new(FlatBufferBuilder::with_capacity(1024));
}

fn serialize_request(
    builder: &mut FlatBufferBuilder<'static>,
    endpoint: Endpoint,
) -> Result<FlowMessage> {
    // use register_worker_request::{FakeRoot, FakeRootArgs, RegisterWorkerRequest, RegisterWorkerRequestArgs};
    unimplemented!();
}

fn deserialize_locality_data(buf: &[u8]) -> Result<()> {
    let locality_data = locality_data::root_as_fake_root(&buf)?;
    println!("{:?}", locality_data);
    Ok(())
}

#[test]
fn test_client_worker_interface_serializer() {
    // TODO.
}

#[test]
fn test_locality_data_serializer() -> Result<()> {
    #[allow(non_snake_case)]
    let buffer_11EnsureTableI12LocalityDataE = vec![
        0x1c, 0x00, 0x00, 0x00, 0xea, 0xbc, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0d,
        0x00, 0x04, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x06, 0x00, 0x08, 0x00, 0x04, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x7a, 0x6f, 0x6e, 0x65, 0x69, 0x64,
        0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x70, 0x72, 0x6f, 0x63, 0x09, 0x00, 0x00, 0x00,
        0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x64, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00,
        0x00, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00,
        0x00, 0x00, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x00, 0x09, 0x00, 0x00, 0x00, 0x6d,
        0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x69, 0x64, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00,
        0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
        0x00, 0x64, 0x63, 0x69, 0x64,
    ];
    deserialize_locality_data(&buffer_11EnsureTableI12LocalityDataE)?;
    Ok(())
}

pub async fn register_worker(svc: &Arc<ConnectionKeeper>, endpoint: Endpoint) -> Result<()> {
    let req =
        REQUEST_BUILDER.with(|builder| serialize_request(&mut builder.borrow_mut(), endpoint))?;
    let res = svc.rpc(req).await?;

    Ok(())
}

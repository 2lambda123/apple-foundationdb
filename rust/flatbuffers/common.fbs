table Void {

}
table Error {
    error: uint;
}

struct UID {
    first : ulong;
    second : ulong;
}

table ReplyPromise {
    uid : UID;
}

table Hostname {
    host: [ubyte];
	service: [ubyte]; // decimal port number
	is_tls: bool;
}

struct IPv4 {
    tag_hack: ubyte; // always set to one; working around flatcc's lack of support for struct s {int} ; union {s, ..} 
    ip: uint;
}

table IPAddress {
    ip4: IPv4;
}

/*
struct IPv4 { // not supported in rust flatcc. :-(
    ip: uint;
}

table IPv6 { // std::array<uint8_t, 16>
    ip0: ubyte;
    ip1: ubyte;
    ip2: ubyte;
    ip3: ubyte;
    ip4: ubyte;
    ip5: ubyte;
    ip6: ubyte;
    ip7: ubyte;
    ip8: ubyte;
    ip9: ubyte;
    ip10: ubyte;
    ip11: ubyte;
    ip12: ubyte;
    ip13: ubyte;
    ip14: ubyte;
    ip15: ubyte;
}

union IPAddressUnion {
    IPv4, IPv6
}

table IPAddress {
    ensure_table: IPAddressUnion;
}
*/

table NetworkAddress {
	// A NetworkAddress identifies a particular running server (i.e. a TCP endpoint).
	// IPAddress ip; // aka: 	std::variant<uint32_t, IPAddressStore> addr;
    ip: IPAddress;
    port: ushort;
    flags: ushort;
    from_hostname: bool;
}

table NetworkAddressFakeRoot {
    network_address: NetworkAddress;
}

union OptionalNetworkAddress {
    NetworkAddress, Void
}

table NetworkAddressList {
    address: NetworkAddress;
    secondary_address: OptionalNetworkAddress;
}

table Endpoint {
    addresses: NetworkAddressList;
    token: UID;
}

table RequestStream {
    /*
    SERIALIZED 13RequestStreamI19OpenDatabaseRequestLb0EE
    SERIALIZED 8Endpoint
    SERIALIZED 18NetworkAddressList
    SERIALIZED 14NetworkAddress
    SERIALIZED 9IPAddress
    UNION 17union_like_traitsISt7variantIJjSt5arrayIhLm16EEEEE
    UNION 17union_like_traitsI8OptionalI14NetworkAddressEE
    SERIALIZED 14NetworkAddress
    SERIALIZED 9IPAddress
    UNION 17union_like_traitsISt7variantIJjSt5arrayIhLm16EEEEE
    */
    endpoint: Endpoint;
}

table ClusterInterface {
    open_database: RequestStream;
    failure_monitoring: RequestStream;
    database_status: RequestStream;
    ping: RequestStream;
    get_client_workers: RequestStream;
    force_recovery: RequestStream;
    move_shard: RequestStream;
    repair_system_data: RequestStream;
    split_shard: RequestStream;
}

// TODO: Move to Endpoint.fbs
table EndpointFakeRoot {
    endpoint: Endpoint;
}
root_type EndpointFakeRoot;
// root_type NetworkAddressFakeRoot;

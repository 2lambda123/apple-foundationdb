table Void {

}
table Error {
    error: uint;
}

struct UID {
    first : ulong;
    second : ulong;
}

table ReplyPromise {
    uid : UID;
}

table Hostname {
    host: [ubyte];
	service: [ubyte]; // decimal port number
	is_tls: bool;
}

struct IPv4 {
    tag_hack: ubyte; // always set to one; working around flatcc's lack of support for struct s {int} ; union {s, ..} 
    ip: uint;
}

table IPAddress {
    ip4: IPv4;
}

// We don't use IDL strings, so we need to roll our own vector of
// string type.  [ubyte] is an FDB string.
table StringVectorEntry {
    string: [ubyte];
}

// We can't have nice things like this.
// You need to write [StringVectorEntry] instead.
// table StringVector {
//     vector: [StringVectorEntry];
// }

/*
struct IPv4 { // not supported in rust flatcc. :-(
    ip: uint;
}

table IPv6 { // std::array<uint8_t, 16>
    ip0: ubyte;
    ip1: ubyte;
    ip2: ubyte;
    ip3: ubyte;
    ip4: ubyte;
    ip5: ubyte;
    ip6: ubyte;
    ip7: ubyte;
    ip8: ubyte;
    ip9: ubyte;
    ip10: ubyte;
    ip11: ubyte;
    ip12: ubyte;
    ip13: ubyte;
    ip14: ubyte;
    ip15: ubyte;
}

union IPAddressUnion {
    IPv4, IPv6
}

table IPAddress {
    ensure_table: IPAddressUnion;
}
*/

table NetworkAddress {
	// A NetworkAddress identifies a particular running server (i.e. a TCP endpoint).
	// IPAddress ip; // aka: 	std::variant<uint32_t, IPAddressStore> addr;
    ip: IPAddress;
    port: ushort;
    flags: ushort;
    from_hostname: bool;
}

union OptionalNetworkAddress {
    NetworkAddress, Void
}

table NetworkAddressList {
    address: NetworkAddress;
    secondary_address: OptionalNetworkAddress;
}

table Endpoint {
    addresses: NetworkAddressList;
    token: UID;
}

table RequestStream {
    /*
    SERIALIZED 13RequestStreamI19OpenDatabaseRequestLb0EE
    SERIALIZED 8Endpoint
    SERIALIZED 18NetworkAddressList
    SERIALIZED 14NetworkAddress
    SERIALIZED 9IPAddress
    UNION 17union_like_traitsISt7variantIJjSt5arrayIhLm16EEEEE
    UNION 17union_like_traitsI8OptionalI14NetworkAddressEE
    SERIALIZED 14NetworkAddress
    SERIALIZED 9IPAddress
    UNION 17union_like_traitsISt7variantIJjSt5arrayIhLm16EEEEE
    */
    endpoint: Endpoint;
}

table ClusterInterface {
    open_database: RequestStream;
    failure_monitoring: RequestStream;
    database_status: RequestStream;
    ping: RequestStream;
    get_client_workers: RequestStream;
    force_recovery: RequestStream;
    move_shard: RequestStream;
    repair_system_data: RequestStream;
    split_shard: RequestStream;
}

table ClientWorkerInterface {
    reboot: RequestStream;
    profiler: RequestStream;
    set_failure_injection: RequestStream;
}

table TesterInterface {
    recruitments: RequestStream;
}

table ConfigBroadcastInterface {
    id: UID;
    snapshot: RequestStream;
    changes: RequestStream;
    registered: RequestStream;
    ready: RequestStream;
}

// The following block is rejected by flatc for multiple reasons, but it's my
// best guess of what FDB emits for the _data field for LocalityData.
/*
struct Empty { // Error: empty structs are not allowed.  Maybe a Void table would work instead?

}
struct StringStruct { // Error: struct's can't contain vectors.
    string: [ubyte];
}

union OptionalString {
    Empty, StringStruct
}

union OptionalString {
    Empty, [ubyte] // Parse error at '['
}

*/
table LocalityDataPair {
    key: [ubyte];
    
    // I think the next two fields are actualy a "union { [ubyte], struct {} }", but that's not supported by flatc.
    // In other words, I think tag and val should be replaced with this:
    // val: OptionalString;

    // tag = 0 means not present.  tag = 1 means present.
    tag: ubyte;
    val: [ubyte];
}

table LocalityData {
    // C++ type: std::map<Standalone<StringRef>, Optional<Standalone<StringRef>>> _data;
    data: [LocalityDataPair];
}

table ProcessClass {
    class: short;
    source: short;
}

table ClusterControllerPriorityInfo {
    process_class_fitness: ubyte;
    is_excluded: bool;
    dc_fitness: ubyte;
}

// N.B. These fields are defined in one order in the struct definition
// and in another order in C++ call to serializer.  The serializer
// call is what matters.
table WorkerInterface {
    client_worker_interface: ClientWorkerInterface;
    locality_data: LocalityData;
    t_log: RequestStream;
    master: RequestStream;
    commit_proxy: RequestStream;
    grv_proxy: RequestStream;
    data_distributor: RequestStream;
    ratekeeper: RequestStream;
    blob_manager: RequestStream;
    blob_worker: RequestStream;
    resolver: RequestStream;
    storage: RequestStream;
    log_router: RequestStream;
    debug_ping: RequestStream;
    coordination_ping: RequestStream;
    wait_failure: RequestStream;
    set_metrics_rate: RequestStream;
    event_log_request: RequestStream;
    trace_batch_dump_request: RequestStream;
    tester_interface: TesterInterface;
    disk_store_request: RequestStream;
    exec_req: RequestStream;
    worker_snap_req: RequestStream;
    backup: RequestStream;
    encrypt_key_proxy: RequestStream;
    update_server_db_info: RequestStream;
    config_broadcast_interface: ConfigBroadcastInterface;
}

table DataDistributorInterface {
    wait_failure: RequestStream;
    halt_data_distributor: RequestStream;
    locality: LocalityData;
    my_id: UID;
    distributor_snap_req: RequestStream;
    distributor_excl_check_req: RequestStream;
    data_distributor_metrics: RequestStream;
    distributor_split_range: RequestStream;
}

union OptionalDataDistributorInterface {
    DataDistributorInterface, Void // TODO: Order may be flipped.
}

table RatekeeperInterface {
    wait_failure: RequestStream;
    get_rate_info: RequestStream;
    halt_ratekeeer: RequestStream;
    report_commit_cost_estimation: RequestStream;
    locality: LocalityData;
    my_id: UID;
}

union OptionalRatekeeperInterface {
    RatekeeperInterface, Void // TODO: Order may be flipped.
}

table BlobManagerInterface {
    wait_failure: RequestStream;
    halt_blob_manager: RequestStream;
    halt_blob_granules: RequestStream;
    blob_manager_excl_check_req: RequestStream;
    locality: LocalityData;
    my_id: UID;
}

union OptionalBlobManagerInterface {
    BlobManagerInterface, Void // TODO: Order may be flipped.
}

// BEWARE: As an optimization, the C++ serializer for this interface
// elites three request streams.  You'll need to use getAdjustedEndpoint to
// infer those endpoints and manually register those endpoints after
// deserializing this.  (Similarly, you'll need to use getAdjustedEndpoint
// if you implement this interface; otherwise, you won't be able to tell peers
// about the endpoints you exposed...)
table EncryptKeyProxyInterface {
    locality: LocalityData;
    my_id: UID;
    wait_failure: RequestStream;
}

union OptionalEncryptKeyProxyInterface {
    EncryptKeyProxyInterface, Void
}

table ConfigClassSet {
    keys: [StringVectorEntry];
}

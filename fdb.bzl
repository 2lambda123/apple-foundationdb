ACTOR_H_SUFFIX = '.actor.h'
ACTOR_CPP_SUFFIX = '.actor.cpp'

ACTOR_SUFFIXES = [
    ACTOR_H_SUFFIX,
    ACTOR_CPP_SUFFIX,
]

def _is_actor(name):
    '''Is the singular source or header addressed by name (e.g.,
    "BlobStore.actor.cpp") an actor file extension we recognize?

    Goes by name alone and does not look at file content.
    '''
    return any([name.endswith(suffix) for suffix in ACTOR_SUFFIXES])

def _to_actor(name):
    '''Given a singular source or header file, return a tuple of:
    - The name of the rule for generating the actor (generally just strips a dot
      so that e.g. "BlobStore.actor.cpp" turns into "BlobStore.actorcpp").
    - A list of sources required to build the actor with the actor compiler.
    - A list of outputs generated by the actor compiler.
    - The dependencies that one would substitute into a sources list that
      contained the actor (e.g., "BlobStore.actor.cpp" returns
      ["BlobStore.actor.g.cpp"] while "LoadBalance.actor.h" returns
      ["LoadBalance.actor.h", "LoadBalance.actor.g.h"].
    '''
    if name.endswith(ACTOR_CPP_SUFFIX):
        label = name[:-4] + 'cpp'
        srcs = [name]
        outs = [name[:-4] + '.g.cpp']
        deps = outs
        return label, srcs, outs, deps
    elif name.endswith(ACTOR_H_SUFFIX):
        label = name[:-2] + 'h'
        srcs = [name]
        outs = [name[:-2] + '.g.h']
        deps = srcs + outs
        return label, srcs, outs, deps
    else:
        fail('do not understand suffix of %s' % name)

def _maybe_actor_compile(name, label, srcs, outs):
    '''Using the actor compilation rules, possibly compile the actor.  This will
    have no effect if the call has already been made once.
    '''
    if native.existing_rule(label) == None:
        native.genrule(
            name = label,
            srcs = srcs,
            outs = outs,
            cmd = "mono $(location //flow/actorcompiler:actorcompiler) $< $@",
            tools = ["//flow/actorcompiler:actorcompiler"],
        )

def _translate_sources(names):
    if names != None:
        new_names = []
        for i, name in enumerate(names):
            if _is_actor(name):
                label, srcs, outs, deps = _to_actor(name)
                _maybe_actor_compile(name, label, srcs, outs)
                new_names += deps
            else:
                new_names.append(name)
        names = new_names
    return names

def actor_compile(name):
    label, srcs, outs, deps = _to_actor(name)
    _maybe_actor_compile(name, label, srcs, outs)

def fdb_utility_library(name, hdrs=None, srcs=None, deps=None, linkopts=None):
    if hdrs != None:
        hdrs = _translate_sources(hdrs)
    if srcs != None:
        srcs = _translate_sources(srcs)
    native.cc_library(
        name = name,
        hdrs = hdrs,
        srcs = srcs,
        deps = deps,
        copts = [
            "-std=c++14",
            # TODO(rescriva) Not providing this flag leads to tests generating
            # excess output that makes them fail and flake on smaller
            # development machines.  Providing this flag limits some test
            # coverage.  Neither are ideal, but a solid signal is preferrable
            # and we can improve the coverage from there.
            "-DNDEBUG",
            # TODO(rescriva) obviously not a good long-term place
            # Re-enable once everything else has proven to build.
            "-DTLS_DISABLED",
            "-DNO_INTELLISENSE",
            "-DUSE_UCONTEXT",
            "-fno-omit-frame-pointer",
            "-fvisibility=hidden",
            "-Wreturn-type",
            "-Wno-unused-function",
            "-O2",
            "-g",
            # TODO(rescriva)
            # Added to silence the compiler
            "-Wno-sign-compare",
            "-Wno-reorder",
            "-Wno-unknown-pragmas",
            "-Wno-comment",
        ],
        linkopts = linkopts,
        visibility = ["//visibility:public"],
    )

def fdb_binary(name, srcs=None, deps=None, linkopts=None):
    if srcs != None:
        srcs = _translate_sources(srcs)
    native.cc_binary(
        name = name,
        srcs = srcs,
        deps = deps,
        copts = [
            "-std=c++14",
            # TODO(rescriva) Not providing this flag leads to tests generating
            # excess output that makes them fail and flake on smaller
            # development machines.  Providing this flag limits some test
            # coverage.  Neither are ideal, but a solid signal is preferrable
            # and we can improve the coverage from there.
            "-DNDEBUG",
            # TODO(rescriva) obviously not a good long-term place
            # Re-enable once everything else has proven to build.
            "-DTLS_DISABLED",
            "-DNO_INTELLISENSE",
            "-DUSE_UCONTEXT",
            "-fno-omit-frame-pointer",
            "-fvisibility=hidden",
            "-Wreturn-type",
            "-Wno-unused-function",
            "-O2",
            "-g",
            # TODO(rescriva)
            # Added to silence the compiler
            "-Wno-sign-compare",
            "-Wno-reorder",
            "-Wno-unknown-pragmas",
            "-Wno-comment",
        ],
        linkopts = linkopts,
        visibility = ["//visibility:public"],
    )

def fdb_test(name, seed='1', size=None):
    if not name.endswith('.txt'):
        fail("specify the text file for the test")
    if size == None:
        if name.startswith('slow'):
            size = 'large'
        else:
            # The default for all other fdb tests
            size = 'medium'
    source = name
    label = '%s_%s_test' % (name[:-4], seed)
    native.sh_test(
        name = label,
        srcs = ["//tests:runner.sh"],
        args = ['"$(location //fdbserver:fdbserver)" "$(location %s)" %s' % (source, seed)],
        size = size,
        data = [
            source,
            "//fdbserver:fdbserver"
        ],
        local = True,
    )
    if seed == '1':
        label = '%s_random_test' % name[:-4]
        native.sh_test(
            name = label,
            srcs = ["//tests:runner.sh"],
            args = ['"$(location //fdbserver:fdbserver)" "$(location %s)" X' % source],
            size = size,
            data = [
                source,
                "//fdbserver:fdbserver"
            ],
            local = True,
        )

/*
 * LockRange.actor.h
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2013-2020 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#if defined(NO_INTELLISENSE) && !defined(FDBCLIENT_LOCKRANGE_ACTOR_G_H)
	#define FDBCLIENT_LOCKRANGE_ACTOR_G_H
	#include "fdbclient/LockRange.actor.g.h"
#elif !defined(FDBCLIENT_LOCKRANGE_ACTOR_H)
	#define FDBCLIENT_LOCKRANGE_ACTOR_H

#include "fdbclient/NativeAPI.actor.h"
#include "fdbclient/FDBTypes.h"

#include "flow/actorcompiler.h" // has to be last include

// (Un)Locks a range in the normal key space. If the database is already locked,
// then a database_locked error is thrown. If (part of) the range is already
// locked, then a range_locks_access_denied error is thrown during commit.
// The range in the request must be within normal key ranges, or the
// range_locks_access_denied is thrown.
ACTOR Future<Void> lockRange(Database cx, LockRequest request);
ACTOR Future<Void> lockRanges(Database cx, std::vector<LockRequest> requests);

class Transaction;

class RangeLockCache {
public:
	using Snapshot = std::vector<std::pair<KeyRange, LockStatus>>;

	enum Reason {
		OK,
		DENIED_EXCLUSIVE_LOCK,
		DENIED_READ_LOCK, // Write access is denied because of read lock held
		ALREADY_LOCKED, // Attempts to lock an already locked range
		ALREADY_UNLOCKED, // Attempts to release locks for an unlocked range
	};

	RangeLockCache() = default;

	// Client tries to add a lock request. If the request can proceed, reason
	// is set to OK and mutations are added to the transaction object.
	// Otherwise, reason gives the error and transaction object is intact.
	// The owner ID is stored in the values of keys in "lockedKeyRanges" key
	// space so that we can verify the transaction has succeeded when getting
	// error_code_commit_unknown_result.
	Reason tryAdd(Transaction* tr, const LockRequest& request, UID owner);

	// Encodes a lock request as a value, used by tryAdd().
	static Value encodeLockValue(LockStatus status, UID lockOwner);

	Reason check(KeyRef key, bool write) const;
	Reason check(KeyRangeRef range, bool write) const;

	bool hasVersion(Version version) const {
		return lockVersion == version;
	}

	void setSnapshot(Version version, const Snapshot& snapshot);

	// Returns snapshots & lock requests in string.
	std::string toString() const;

	// ======== Proxy uses the following methods ========
	// The corresponding mutations are generated by tryAdd() at client side
	// and is applied at applyMetadataMutation().

	// Adds a lock's begin key to the "lockedKeyRanges" key space with its status,
	// commit version, and a random owner ID. The owner ID is used to ensure the
	// idempotency of the client transaction, which can be queried by client via
	// reading the key's value back. This owner ID is not sent back in the snapshot.
	// The locked range ends at the next key in the "lockedKeyRanges" key space.
	void add(KeyRef beginKey, LockStatus status, Version version);

	// Clears a range in the cache. This mutation is generated by tryAdd() at the
	// client side.
	void clear(KeyRangeRef range);

	// Decodes the value of lock mutations generated in tryAdd().
	static std::pair<LockStatus, UID> decodeLockValue(StringRef value);

	// Only commit proxy sets version when recovering from txnStateStore.
	void setVersion(Version version) { lockVersion = version; }

	std::pair<Snapshot, Version> getSnapshot() const;

	// Allow access for all key ranges. This is useful for fdbserver processes
	// and clients that wish to do so.
	void setBypassCheck() { ignoreLocks = true; }

	bool bypassCheck() { return ignoreLocks; }

private:
	Version lockVersion = invalidVersion; // the latest commit version of locks
	KeyRangeMap<LockStatus> locks; // locked key ranges
	bool ignoreLocks = false;
};

#include "flow/unactorcompiler.h"
#endif
